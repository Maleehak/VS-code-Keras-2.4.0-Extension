{"Keras 2.4.0 Resnet50":{
    "prefix": "!resnet50",
    "body":  [
        "from tensorflow.keras.applications.resnet50 import ResNet50",
        "from tensorflow.keras.preprocessing import image",
        "from tensorflow.keras.applications.resnet50 import preprocess_input, decode_predictions",
        "import numpy as np",
        "\n",
        "model = ResNet50(weights='${1:type}')",
        "\n",
        "img_path = ${2: pathname}",
        "img = image.load_img(img_path, target_size=(224, 224))",
        "x = image.img_to_array(img)",
        "x = np.expand_dims(x, axis=0)",
        "x = preprocess_input(x)",
        "\n",
        "preds = model.predict(x)",
        "# decode the results into a list of tuples (class, description, probability)",
        "# (one such list for each sample in the batch)",
        "print('Predicted:', decode_predictions(preds, top=3)[0])"
    ],
    "description":"Classifies ImageNet classes with ResNet50"
    },
"Keras 2.4.0 VGG 16":{
    "prefix": "!vgg16",
    "body":  [
        "from tensorflow.keras.applications.vgg16 import VGG16",
        "from tensorflow.keras.preprocessing import image",
        "from tensorflow.keras.applications.vgg16 import preprocess_input",
        "import numpy as np",
        "\n",
        "model = VGG16(weights='${1:type}', include_top=${2: False})",
        "\n",
        "img_path = ${3:pathname}",
        "img = image.load_img(img_path, target_size=(224, 224))",
        "x = image.img_to_array(img)",
        "x = np.expand_dims(x, axis=0)",
        "x = preprocess_input(x)",
        "\n",
        "features = model.predict(x)"
    ],
    "description":"Extracts features with VGG16"
        },
"Keras 2.4.0 VGG 19":{
    "prefix": "!vgg19",
    "body":  [
        "from tensorflow.keras.applications.vgg16 import VGG19",
        "from tensorflow.keras.preprocessing import image",
        "from tensorflow.keras.applications.vgg19 import preprocess_input",
        "import numpy as np",
        "\n",
        "base_model = VGG19(weights='${1:type}')",
        "model = Model(inputs=base_model.input, outputs=base_model.get_layer('block4_pool').output)",
        "\n",
        "img_path = ${2:pathname}",
        "img = image.load_img(img_path, target_size=(224, 224))",
        "x = image.img_to_array(img)",
        "x = np.expand_dims(x, axis=0)",
        "x = preprocess_input(x)",
        "\n",
        "block4_pool_features = model.predict(x)"
    ],
    "description":"Extracts features from an arbitrary intermediate layer with VGG19"
    },
"Keras 2.4.0 InceptionV3":{
    "prefix": "!inceptionv3",
    "body":  [
        "from tensorflow.keras.applications.inception_v3 import InceptionV3",
        "from tensorflow.keras.preprocessing import image",
        "from tensorflow.keras.models import Model",
        "from tensorflow.keras.layers import Dense, GlobalAveragePooling2D",
        "\n",
        "# create the base pre-trained model",
        "base_model = InceptionV3(weights='${1:type}', include_top=${2: False})",
        "# add a global spatial average pooling layer",
        "x = base_model.output",
        "x = GlobalAveragePooling2D()(x)",
        "# let's add a fully-connected layer",
        "x = Dense(1024, activation='relu')(x)",
        "# and a logistic layer -- let's say we have 200 classes",
        "predictions = Dense(200, activation='softmax')(x)",
        "\n",
        "# this is the model we will train",
        "model = Model(inputs=base_model.input, outputs=predictions)",
        "\n",
        "# first: train only the top layers (which were randomly initialized)",
        "# i.e. freeze all convolutional InceptionV3 layers",
        "for layer in base_model.layers:",
        "   layer.trainable = False",
        "\n",
        "# compile the model (should be done *after* setting layers to non-trainable)",
        "model.compile(optimizer='rmsprop', loss='categorical_crossentropy')",
        "\n",
        "# train the model on the new data for a few epochs",
        "model.fit(...)",
        "\n",
        "# at this point, the top layers are well trained and we can start fine-tuning",
        "# convolutional layers from inception V3. We will freeze the bottom N layers",
        "# and train the remaining top layers.",
        "\n",
        "# let's visualize layer names and layer indices to see how many layers",
        "# we should freeze:",
        "for i, layer in enumerate(base_model.layers):",
        "   print(i, layer.name)",
        "/n",
        "# we chose to train the top 2 inception blocks, i.e. we will freeze",
        "# the first 249 layers and unfreeze the rest:",
        "for layer in model.layers[:249]:",
        "   layer.trainable = False",
        "for layer in model.layers[249:]:",
        "   layer.trainable = True",
        "\n",
        "# we need to recompile the model for these modifications to take effect",
        "# we use SGD with a low learning rate",
        "from tensorflow.keras.optimizers import SGD",
        "model.compile(optimizer=SGD(lr=0.0001, momentum=0.9), loss='categorical_crossentropy')",
        "/n",
        "# we train our model again (this time fine-tuning the top 2 inception blocks",
        "# alongside the top Dense layers",
        "model.fit(...)"
    ],
    "description":"Fine-tunes InceptionV3 on a new set of classes"
    },
"Keras 2.4.0 InceptionV3 Custom tensor":{
    "prefix": "!inceptionv3custom",
    "body":  [
        "from tensorflow.keras.applications.inception_v3 import InceptionV3",
        "from tensorflow.keras.layers import Input",
        "\n",
        "# this could also be the output a different Keras model or layer",
        "input_tensor = Input(shape=(224, 224, 3))",
        "\n",
        "model = InceptionV3(input_tensor=input_tensor, weights='imagenet', include_top=True)"
    ],
    "description":"Builds InceptionV3 over a custom input tensor"
    }
    
}